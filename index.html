<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="description" content="Oculus Render : 15-418 Final Project">

  <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/languages/cpp.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <title>Conduit: Efficient Video Compression for Live VR Streaming</title>
</head>

<body>

<!-- HEADER -->
<div id="header_wrap" class="outer">
  <header class="inner">
    <a id="forkme_banner" href="https://github.com/avp/conduit">View on GitHub</a>

    <h1 id="project_title">Conduit</h1>

    <h2 id="project_tagline">
      Efficient Video Compression for Live VR Streaming
    </h2>

    <h3 id="project_author">
      Aakash Patel &amp; Gregory Rose
    </h3>

    <section id="downloads">
      <a class="zip_download_link" href="https://github.com/avp/conduit/zipball/master">
        Download this project as a .zip file
      </a>
      <a class="tar_download_link" href="https://github.com/avp/conduit/tarball/master">
        Download this project as a tar.gz file
      </a>
    </section>
  </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
    <h4>
      <a href="proposal.html">[Proposal]</a>
      &nbsp;
      <a href="checkpoint.html">[Checkpoint]</a>
      <br />
      <a href="conduit_final_presentation.pdf" target="_blank">[Final Presentation PDF]</a>
    </h4>

    <h2>Problem</h2>

    <p>
      The experience of live events
      &mdash; concerts, sporting events, parades, and even being at Times Square on New Years &mdash;
      is powerful.
      Yet, these same events, viewed live at home on a TV, feel far more distant and less immersive.
      We believe that virtual reality (VR) can provide a far more immersive live experience than TV, by adding presence, the feeling that “you’re really there”.
      However, one of VR’s key advantages, the fact that you have the freedom to look anywhere in 360&deg;, requires using a fully panoramic video.
      Panoramic videos are large, often 4K resolution (4096 pixels wide, 2048 pixels tall, depending on the standard).
      In addition, VR headsets typically work in 3D, meaning you need a panoramic video for each eye, so you’re streaming effectively a 4096x4096 video.
    </p>

    <p>
      This requires a very high amount of bandwidth &mdash; at least 25 Mbps (for 2D 4K at half the size),
      <a href="https://help.netflix.com/en/node/13444">according to Netflix</a>.
      However, <a href="http://www.scribd.com/doc/259862003/State-of-the-Internet-Report-Q4-2014">according to Akamai</a>,
      the average American internet speed is about 11 Mbps.
      In addition, while 4G internet can get almost to the 4K streaming point,
      <a href="https://bgr.com/2013/03/11/4g-network-speeds-368339/">at 20 Mbps down</a>,
      on average it's a lot lower (typically more like ~11 Mbps).
      In addition, you'd want a higher bandwidth than you need to provide better stability and account for overhead.
      This effectively prohibits live streaming on mobile VR on all but some of the fastest internet connections in America.
    </p>

    <h2>Solution</h2>

    <p>
      Conduit is a project to reduce these bandwidth requirements
      for streaming live 4K panoramic video to a head-mounted display (HMD) like the <a
      href="https://www.oculus.com/">Oculus Rift</a>.
      We do this by using view-optimization, <strong>optimizing</strong> the video stream by compressing it,
      because we know what your <strong>view</strong> (where you’re looking) is,
      since the direction you’re looking at is reported by the HMD.
    </p>

    <p>
      Before streaming a frame over, we crop it to just the part you can see, instantly reducing total size by over 50%.
      Next, we use foveated rendering, a technique which takes advantage of the fact that the human eye does not have uniform resolution:
      our eyes have significantly higher resolution in the center region, called the fovea.
      Therefore, we downsample the outer regions, which comprise most of the image, saving even more space.
      However, because of this, you could move your head fast enough that it got outside the “view” region of the last streamed frame,
      and so we introduce multiple techniques to mitigate this by adaptively changing
      the compression parameters, adding buffer room, and taking advantage of the GPU to
      reduce latency.
    </p>

    <h2>Scope</h2>

    <p>
      Fully investigating view optimization would require many weeks of full-time work.
      In order to scope this to be doable as a class project, we decided to focus on getting the view-optimization
      to work so that we could see how it looks, and optimizing the graphics as much as we could.
      The client and server are integrated into one program, and so we simply do
      <code>decode_frame(optimize_frame(frame))</code>.
      The Oculus DK2 does not have eye tracking capabilities, so we assume your eyes focus straight ahead at all
      times relative to the head.
    </p>

    <h2>Technologies</h2>

    <p>
      We used <b>OpenCV</b> to read frames from the H.264-encoded MP4 video file.
      The library handles video reading and decoding using <b>FFMpeg</b>.
    </p>

    <p>
      For graphics, we used <b>OpenGL</b>, <b>GLEW</b>, and <b>GLUT</b>.
      OpenGL is used for texture mapping and rendering the cylinders to a screen.
      GLUT is able to render cylinders for us, which we can map textures onto.
      The textures are the frames from the video that we want to show to the user.
      The window manager is <b>SDL2</b>, which we use to look at the images generated by the graphics libraries.
    </p>

    <p>
      We also used an <b>Oculus Rift DK2</b> and its SDK.
      We sent our view-optimized images to the Oculus display where the video could be viewed.
    </p>

    <h2>Optimization</h2>

    <h3>Initial Version</h3>

    <p>
      Our first approach used a render loop like the following:
    </p>

<pre><code>OptimizedFrame optimize_frame(video_frame, viewer_data) {
  // crop_frame crops the frame to your FOV,
  // handling edge cases like if the viewer is looking
  // at the part of the panorama where the ends are stitched together.
  cropped_frame = crop_frame(video_frame, viewer_data.angle, 90);

  // extract the center 20 degrees
  left, center, right = horizontal_split(cropped_frame, 20);
  top, middle, bottom = vertical_split(center, 20);

  // shrink by a pre-defined constant factor of 5
  left = shrink(left);
  right = shrink(right);
  top = shrink(top);
  bottom = shrink(bottom);

  return OptimizedFrame(left, right, top, middle, bottom);
}

Frame decode_frame(optimized) {
  left = expand(optimized.left);
  right = expand(optimized.right);
  top = expand(optimized.top);
  bottom = expand(optimized.bottom);
  middle = optimized.middle;

  center = vertical_concat(top, middle, bottom);
  return horizontal_concat(left, center, right);
}

OpenGLTexture texture; // reference a texture on the GPU

while (true) {
  video_frame = get_video_frame();

  // We actually do each of these steps once for each eye,
  // having split video_frame into a "left eye" and "right eye"
  optimized_frame = optimize_frame(video_frame, viewer_data);
  decoded_frame = decode_frame(optimized_frame);

  copy_frame_to_texture(decoded_frame, texture);
  viewer_data = get_viewer_data_from_hmd();

  render_frame(decoded_frame, viewer_data);
}</code></pre>

      <!--Profiling-->

    <h3>Optimization 1: Async Video Loading</h3>

    <p>
      Loading the video every single frame was taking a long time.
      Our first realization was that the work of loading the video frame is completely independent from the rest of the code!
      So while we’re optimizing, decoding, rendering, we can load more video frames in parallel.
      We created a second thread  to “buffer” the video, loading video frames continuously in the background,
      and putting them onto a queue, where the main thread could take them off.
    </p>

    <p>
      We limited the queue to 10 decoded frames, since decoded frames can be quite large (4096x4096 pixels * 24 bits/pixel for RGB 8-bit is 50.33 MB).
    </p>

    <p>
      <!--This cut down our frame time by XXXX-->
      We also found the video decoding ran much faster than the main loop, so the queue would
      quickly fill up and stay full.
      It may be worth revisiting (decode multiple frames in parallel) once everything else is optimized.
    </p>

    <p>
      As a secondary optimization, we found that our dequeue function waited for a frame to be available.
      This meant that the main loop couldn’t run faster than video frames were decoded,
      and even if video frames were decoded slightly faster, if the video reader ever hung temporarily,
      it’d cause a hiccup in the main loop.
      In VR, it’s particularly important to have a fast main loop,
      since that’s where the frame is updated to reflect head-tracking,
      and high-latency and low framerates on head-tracking cause motion sickness.
      We then changed dequeue to just return <code>NULL</code> immediately if no frame was available,
      and in that case simply skipped updating the frame in the main loop.
      <!--This cut down our frame time by XXX.-->
    </p>

    <h3>Optimization 2: Simplifying the View-optimizer</h3>

    <p>
    We implemented view optimization and measured results from that.
    </p>

    <p>
      <b>First Attempt:</b>
      First, we cropped the panoramic video frame that was read to 180&deg;
      in order to exclude regions that would be too far for the user to turn their head to see.
      Then, taking a yaw and a pitch, we compressed the image.
      To do this, we divided the image up horizontally: left, middle (the inner 20&deg;), and right.
      We scaled down the left and right sides by a factor of 5.
      The middle image was split into top, center and bottom sections.
      The top and bottom sections were similarly scaled down by a factor of 5.
      The middle section was left at full resolution.
    </p>

    <p>
      This way, we had a section in the middle of the image that the user could see as being completely in focus,
      and the rest of the image was blurry, in order to have a smaller size in memory &mdash;
      this optimized image would, in real world circumstances, be sent over a network.
      We measured the time that each of the steps in the view optimization took.
    </p>

    <p>
      <b>Problem:</b>
      On analysis, we saw that the slowest steps, by far, were the resizing steps of the optimizer.
      Each resizing section took over 100 times longer than any other step.
    </p>

    <p>
      <b>Solution:</b>
      Our initial attempt tried to save space by splitting the image into exclusive regions, and operating on them individually.
      To restore, we would then scale each piece back up and concatenate them, first reassembling the vertical column, then reassembling the horizontal pieces.
      This was far too complicated, and error-prone, resulting in numerous bugs and edge cases.
      In addition, the multiple concatenations each copied every single pixel, meaning many pixels were copied multiple times, which is inefficient.
    </p>

    <p>
      We fixed this by using a simpler approach, whereby we simply extract the center square at full resolution,
      and then take the entire image and scale it down.
      Then, to reconstruct it, we re-expand the cropped image to the original size,
      and paint the focused sub-image back in the center.
      While this does mean we now have redundant information for the center piece,
      the simpler approach overall reduced view-optimization time from ~26ms to ~18ms.
    </p>

    <h3>Optimization 3: Pixel Buffer Objects</h3>

    <p>
      We next address the issue of <code>copy_frame_to_texture</code>,
      which copies our decoded frame to the OpenGL texture, which is stored on the GPU.
      At first, we thought the primary issue was being bandwidth bound,
      but we profiled with the NVIDIA X Server Info tool, and found that GPU bandwidth wasn’t even near being fully
      used.
    </p>

    <p>
      We found the problem to be using <code>glTexImage2D</code> to copy
      the texture to the GPU every single time we got a new video frame.

      It turns out that <code>glTexImage2D</code> is blocking,
      i.e. it waits for the GPU to be available, and in particular done using the texture, before copying.
      In other words, it wastes a lot of time waiting around.
    <p>

    <p>
      We found a better solution to be using pixel-buffer objects (PBO).
      These allow you to copy your image data into a “pixel buffer”, and then tell the GPU to copy it into the texture,
      but it runs asynchronously.
      This is similar to asynchronous message passing from class.
      Using pixel-buffer objects reduced the time to copy textures from ~20ms to ~2ms,
      and since we do it once for each eye, it’s about a ~40ms win on total frame time
    <p>

    <h3>Optimization 4: Pipelining Frame View-Optimization</h3>

    <p>
      We found the next bottleneck to be frame optimization, taking over 30ms.
      Taking a hint from optimization 1, we made this asynchronous as well.
      This didn't affect the total time a frame spent in the pipeline, but reduced
      motion-to-photon latency, making the experience more comfortable.
    </p>

    <p>
      A slight issue is that view-optimization requires sensor data, but the Oculus SDK sensor-reading functions
      are not thread-safe and must be executed on the main thread. Therefore, we copy them over periodically in the
      main thread, along with a timestamp of the time the sensor data was generated. We use a simple mutex for
      synchronization since these are very small constant-sized pieces of data that aren't accessed often.
      If we had more time, we would also optimize placement of updating the viewer data on the main thread, and
      possibly due it multiple times per loop.
    </p>

<pre><code>// T1
Queue frameQueue;
Frame frame = frameQueue.dequeue();
ViewerData viewerData;

while (true) {
  if (frameQueue.hasNewFrame())
    frame = frameQueue.dequeue();
    viewer_data = get_viewer_data_from_hmd();
    T2.mutex.lock();
    T2.viewer_data = viewer_data;
    T2.mutex.unlock();

    render_frame(optimized_frame, viewer_data);
}

// T2
ViewerData viewer_data;
Mutex mutex;
while (videoFrameAvailable()) {
    mutex.lock();
    local_viewer_data = viewer_data;
    mutex.unlock();

    frame = readFrame();
    frame = decode_frame(optimize_frame(frame, local_viewer_data));
    frameQueue.enqueue(frame);
}</code></pre>

    <h3>Optimization 5: Pose Prediction</h3>

    <p>
      Our optimizer works by taking the HMD’s orientation, and then turning it into an OptimizedFrame.
      This frame then has to go through the Optimizer->Renderer queue, and then arrive at the main rendering call.
      But by the time this has happened, about 70ms have passed (this is motion-to-update time, see results),
      and the data the optimized frame was based on is out of date.
    </p>

    <p>
      So, we automatically measure motion-to-update time (M2U) using a rolling average.
      We then feed this measurement to the Oculus SDK, which provides a
      <a href="https://www.oculus.com/blog/the-latent-power-of-prediction/" target="_blank">prediction</a>
      for where your head will be when you see the frame.
      Note that Oculus clamps predictions to 100ms in the future,
      so we have trouble with spikes, but fortunately we’re about 70ms M2U on average.
      It's harder to measure prediction, although we could compare the position you arrived at with the position the
      view-optimization was for, but it made a noticeable difference.
      Keep in mind that it's much more ok to have a higher M2U than motion-to-photons, since the focus window is
      padded to make it larger than it needs to be.
    </p>

    <h3>Other miscellaneous optimizations</h3>
    We performed several other optimizations such as optimizing for the API by removing unnecessary calls,
    using display lists, and etc, too small but numerous to list entirely here.

    <h2>Results</h2>

    <h3>Experimental Setup</h3>

    <p>
      We ran our demo on a Samsung Chronos 7 laptop with a NVIDIA GeForce GT 630M running Ubuntu 14.10.
      We ran it for 2 minutes while wearing it and looking around.
      We used a <a href="http://photocreations.ca/3D/fountain-3D-4k.mp4" target="_blank">this video</a> from <a href="http://photocreations.ca/3D/" target="_blank">Photocreations</a>.
      It outputs averages of all the statistics we gave here.
      Our code is available at
      <a href="https://github.com/avp/conduit" target="_blank">avp/conduit</a>
      .
      To run our demo, we used:
      <pre><code>./conduit oculus2 fountain-3D-4k.mp4</code></pre>
    </p>

    <p>
      We used an Oculus Rift DK2 to run Conduit and took qualitative measurements, as well as key time metrics.
      We measured <b>motion to update (M2U) latency</b>, which is the time from when you move your head to when you see the view-optimized image for your new angle.
    </p>

    <h3>Qualitative Results</h3>

    <p>
      We found that blur was not particularly noticeable at <b>blur factor</b> (the factor by which we rescale each dimension of the image) 3, although you could "notice" it by toggling blur on and off, you didn't really care, and also, not having everything be in focus is more realistic.

      It became more noticeable at 4 and 5. Although, this is just qualitative experience for us, other people may be different.

      To test tracking, we turned blur factor up to 40 to make it really obvious where the focus window is, and tracking
       was quite responsive. Oculus's prediction helped quite a lot with responsiveness, and also, since the focus
      and crop regions are larger than necessary, and head-tracking updates are decoupled, we found motion-to-update
      could safely exceed the recommended 20ms for motion-to-photons.

      Making the focus window larger helped a lot both when moving and stationary.
      Since it turns out the focus window is only a few percentage points of the entire video,
      this didn't even cost much.
    </p>

    <h3>Quantitative Results</h3>
    <p>
      The bandwidth requirement for streaming 3D 4K video was a minimum of 18 Mbps for our specific H.264 encoded video.
      Our view optimization compressed the image down in terms of raw pixels to 10% the size.

      Cropping removes 50% of the frame.
      We shrink the image by a factor of 3 in each dimension, ke
      We blur the image by a factor of 9, and we only keep a 50&deg; by 50&deg;
      window in the middle of the frame (only 3% of the overall frame).

      Assuming video compression is linear, we cut down bandwidth to 1.8 Mbps, making it much more accessible.
    </p>

    <p>
      We got a motion-to-update latency of 75ms. This was comprised of about 50ms for view-optimization,
      and 25ms spent waiting in the buffer and miscellaneous overhead.

      Also, our optimizations brought the time per frame down from 150ms/frame (6 FPS)  to about 19ms/frame (~50 FPS).
      12ms were spent on display, and 7ms were spent loading the texture.
      Video reading and optimization take almost no time, because we hide latency by pipelining those operations.
    </p>

    <h3>Bottlenecks and further areas of improvement</h3>

    <!-- What limited speedup? Provide data and measurements. -->
    <!-- This is a good way to get credit even if we didn't accomplish our objective. -->
    <!-- Deeper analysis talks about execution time as distinct components, with proportions of time spent. -->

    <!-- Optimization pipeline is bottleneck -->
    <!-- Latency from blurring in optimization -->

    <p>
      The main bottleneck is the optimization pipeline.
      Blurring and resizing the images is the overwhelming majority of time spent in the view optimizer.
      In order to improve this, we could use the GPU for image resizing to try and make the resize operation faster.
      We wanted to accomplish this via OpenCV's CUDA mode, but unfortunately couldn't get it to build in time.

      We also wanted to use
      <a href="http://docs.nvidia.com/cuda/video-decoder/" target="_blank">NVIDIA's CUDA Decoder</a>,
      to get GPU accelerated decoding.
      Also, by doing both of these steps on the GPU, we could <b>keep intermediary data on the GPU</b>.

      To improve updating the orientation angle of the user’s head, we also added prediction of the future head position.
      This greatly improved the lag when the user’s head moved quickly, because the optimization pipeline would optimize for the future.
    </p>

    <p>
      Latency also arises from texture mapping the frames onto the cylinder using OpenGL.
      This takes 7ms of the 19ms motion to update latency, and the project could benefit from making it go faster.
      We could also try reducing the data transfer into the texture, since most of it is black.
      Although performing all view-optimization compression and decompression on the GPU would
      obviate the need for this.
    </p>

    <p>
      Although we've tried to incorporate as much modern graphics programming as we had time to learn and
      implement, we're still using OpenGL immediate mode to render the cylinder.
      We also added display lists, but they didn't help much.
      Moving to an even more modern shader/buffer model would probably improve the 12ms display time.
    </p>

    <h3>Choice of target machine</h3>
    <p>
      Our choice of target machine was limited, so if we had used a better computer, than say, a 2 year old laptop, we could've had faster render times.
      But, we were limited to the computers we owned, since we need physical access to plug in the HMD, and both of us only had laptops.
      Also, we found out that apparently our test video at 4098x4098 just barely exceeded the maximum supported GPU accelerated video decoding size of 4032x4032.
      We tried to rectify this by editing the video, but it crashed every computer we had access too.
      Apparently the video was also bigger than the H.264 codec technically allowed.
    </p>

    <h3>Next steps</h3>
    <p>
      This is a list of some of the things we'd do to continue the project if we had more time:
    </p>
    <ul>
      <li>Compile OpenCV with CUDA and OpenGL support, instantly accelerating optimization</li>
      <li>Try out the CUDA video decoder</li>
      <li>Profile the entire project with NVIDIA Nsight</li>
      <li>Make the optimizer multi-threaded (can optimize multiple frames at once)</li>
      <li>Investigate a performance leak possibly related to the DK2 where displaying the image would take up to
        40ms longer sometimes (but was fixed by rebooting)</li>
      <li>Try using a slightly smaller 4000x4000 video. The graphics card we used said its fixed-function
        decoder was maximum size 4032x4032, slightly smaller than the video. Unfortunately, attempting to resize
        the video crashed most video editors we tried, and the ones that didn't simply refused to create the
        resolution (Adobe Premiere, Final Cut Pro, running on a friend's much higher-end Macbook).</li>
      <li>Asynchronous timewarp</li>
      <li>Actual server-client setup</li>
    </ul>

    <h3>References</h3>
    <ul>
      <li>
        <a href="http://www.gdcvault.com/play/1021771/Advanced-VR" target="_blank">
          Advanced VR Rendering
        </a> (for general understanding)
      </li>
      <li>
        <a href="https://www.oculus.com/blog/the-latent-power-of-prediction/" target="_blank">
          Oculus Blog: The Latent Power of Prediction
        </a>
      </li>
      <li>
        <a href="https://developer.nvidia.com/system/files/akamai/gamedev/docs/Fast_Texture_Transfers.pdf" target="_blank">
          NVIDIA: Fast texture transfers
        </a>
      </li>
    </ul>

    <h3>Context</h3>

    <p>
    Conduit was created as a
    <a href="http://15418.courses.cs.cmu.edu/spring2015/article/10" target="_blank">final project</a> in
    <a href="http://15418.courses.cs.cmu.edu/spring2015/" target="_blank">
      15-418: Parallel Computer Architecture and Programming</a>,
    taught by <a href="https://www.cs.cmu.edu/~kayvonf/" target="_blank">
    Kayvon Fatahalian</a>
    at Carnegie Mellon University. <br /> <br />

    We thank Professor Kayvon and the TAs for their advice along the way!
    </p>

  </section>
</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    <p class="copyright">
      Conduit maintained by
      <a href="https://github.com/avp">avp</a>
      and
      <a href="https://github.com/grrosegr">grrosegr</a>
    </p>
  </footer>
</div>

</body>
</html>
