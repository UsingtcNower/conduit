<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="description" content="Oculus Render : 15-418 Final Project">

  <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/languages/cpp.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <title>Conduit: Efficient Video Compression for Live VR Streaming</title>
</head>

<body>

<!-- HEADER -->
<div id="header_wrap" class="outer">
  <header class="inner">
    <a id="forkme_banner" href="https://github.com/avp/conduit">View on GitHub</a>

    <h1 id="project_title">Conduit</h1>

    <h2 id="project_tagline">
      Efficient Video Compression for Live VR Streaming
    </h2>

    <h3 id="project_author">
      Aakash Patel &amp; Gregory Rose
    </h3>

    <section id="downloads">
      <a class="zip_download_link" href="https://github.com/avp/conduit/zipball/master">
        Download this project as a .zip file
      </a>
      <a class="tar_download_link" href="https://github.com/avp/conduit/tarball/master">
        Download this project as a tar.gz file
      </a>
    </section>
  </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
    <h4>
      <a href="proposal.html">[Proposal]</a>
      &nbsp;
      <a href="checkpoint.html">[Checkpoint]</a>
    </h4>

    <h2>Problem</h2>

    <p>
      The experience of live events
      &mdash; concerts, sporting events, parades, and even being at Times Square on New Years &mdash;
      is powerful.
      Yet, these same events, viewed live at home on a TV, feel far more distant and less immersive.
      We believe that virtual reality (VR) can provide a far more immersive live experience than TV, by adding presence, the feeling that “you’re really there”.
      However, one of VR’s key advantages, the fact that you have the freedom to look anywhere in 360&deg;, requires using a fully panoramic video.
      Panoramic videos are large, often 4K resolution (4096 pixels wide, 2048 pixels tall, depending on the standard).
      In addition, VR headsets typically work in 3D, meaning you need a panoramic video for each eye, so you’re streaming effectively a 4096x4096 video.
    </p>

    <p>
      This requires a very high amount of bandwidth &mdash; at least 25 Mbps,
      <a href="https://help.netflix.com/en/node/13444">according to Netflix</a>.
      However, <a href="http://www.scribd.com/doc/259862003/State-of-the-Internet-Report-Q4-2014">according to Akamai</a>,
      the average American internet speed is about 11 Mbps.
      In addition, while 4G internet can get almost to the 4K streaming point,
      <a href="https://bgr.com/2013/03/11/4g-network-speeds-368339/">at 20 Mbps down</a>,
      on average it's a lot lower.
      This effectively prohibits live streaming on mobile VR on all but some of the fastest internet connections in America.
    </p>

    <h2>Solution</h2>

    <p>
      Conduit is a project to reduce these bandwidth requirements
      for streaming live 4K panoramic video to a head-mounted display (HMD) like the <a
      href="https://www.oculus.com/">Oculus Rift</a>.
      We do this by using view-optimization, <strong>optimizing</strong> the video stream by compressing it,
      because we know what your <strong>view</strong> (where you’re looking) is,
      since the direction you’re looking at is reported by the HMD.
    </p>

    <p>
      Before streaming a frame over, we crop it to just the part you can see, instantly reducing total size by over 50%.
      Next, we use foveated rendering, a technique which takes advantage of the fact that the human eye does not have uniform resolution:
      our eyes have significantly higher resolution in the center region, called the fovea.
      Therefore, we downsample the outer regions, which comprise most of the image, saving even more space.
      However, because of this, you could move your head fast enough that it got outside the “view” region of the last streamed frame,
      and so we introduce multiple techniques to mitigate this by adaptively changing the compression parameters and taking advantage of the GPU to reduce latency.
    </p>

    <!--<h2>Preliminary Results</h2>-->

    <!--<p>-->
      <!--We have a baseline working renderer that can read videos and render them to the Oculus.-->
      <!--The frames are view optimized, and they account for the rotation of the viewer’s head.-->
      <!--With our view optimization, we compress images to about 10% of their original size.-->
    <!--</p>-->

    <!--<p>-->
      <!--To simulate a client-server setup, we had our optimizer optimize a given frame,-->
      <!--and then extract the unoptimized image to figure out how much time it would take.-->
      <!--Optimization is a process that takes the viewer’s head position and the video frame,-->
      <!--and gives back a smaller data structure that contains the optimized image.-->
      <!--The optimized image would be sent over a network.-->
      <!--The client would then extract the image and display it on the HMD.-->
    <!--</p>-->

    <!--<p>-->
      <!--Additionally, we’ve made optimizations that, as much as we can measure now,-->
      <!--reduce the average time per frame from 140ms as measured on a Samsung Chronos 7 with Nvidia GT 630M, to 90 ms.-->
      <!--We measured motion to update (M2U) latency,-->
      <!--which is the time from when you move your head to when you see the updated image appear on the HMD.-->
    <!--</p>-->

    <!--<p>-->
      <!--When viewing the video through the Oculus, we did not notice the blurring that was done outside of the focused region of the frame.-->
      <!--Our blur factor for the final test was only 3, which wasn’t noticeable on the edges of our vision.-->
      <!--When we turn quickly, the screen never goes noticeably black on the edges where it’s been cropped.-->
    <!--</p>-->

    <!--<p>-->
      <!--Through the optimizations, our motion to update latency was reduced from 150ms to 75ms.-->
      <!--This resulted in a frame rate of 50 FPS, or about 19 ms/frame.-->
      <!--12ms were spent on display, and 7ms were spent loading the texture.-->
      <!--Video reading and optimization take almost no time, because we hide latency by pipelining those operations.-->
    <!--</p>-->

    <h2>Technologies</h2>

    <p>
      We used <b>OpenCV</b> to read frames from the MP4 video file. The library handles video reading and decoding using FFMpeg.
    </p>

    <p>
      For graphics, we used <b>OpenGL</b>, <b>GLEW</b>, and <b>GLUT</b>.
      OpenGL is used for texture mapping and rendering the cylinders to a screen.
      GLUT is able to render cylinders for us, which we can map textures onto.
      The textures are the frames from the video that we want to show to the user.
      The window manager is <b>SDL2</b>, which we use to look at the images generated by the graphics libraries.
    </p>

    <p>
      We also used the <b>Oculus Rift<</b> and its SDK. We sent our view-optimized images to the Oculus display where the video could be viewed.
    </p>

    <h2>Optimization</h2>

    <h3>Initial Version</h3>

    <p>
      Our first approach used a render loop like the following:
    </p>

<pre><code>OptimizedFrame optimize_frame(video_frame, viewer_data) {
  // crop_frame crops the frame to your FOV,
  // handling edge cases like if the viewer is looking
  // at the part of the panorama where the ends are stitched together.
  cropped_frame = crop_frame(video_frame, viewer_data.angle, 90);

  // extract the center 20 degrees
  left, center, right = horizontal_split(cropped_frame, 20);
  top, middle, bottom = vertical_split(center, 20);

  // shrink by a pre-defined constant factor of 5
  left = shrink(left);
  right = shrink(right);
  top = shrink(top);
  bottom = shrink(bottom);

  return OptimizedFrame(left, right, top, middle, bottom);
}

Frame decode_frame(optimized) {
  left = expand(optimized.left);
  right = expand(optimized.right);
  top = expand(optimized.top);
  bottom = expand(optimized.bottom);
  middle = optimized.middle;

  center = vertical_concat(top, middle, bottom);
  return horizontal_concat(left, center, right);
}

OpenGLTexture texture; // reference a texture on the GPU

while (true) {
  video_frame = get_video_frame();

  // We actually do each of these steps once for each eye,
  // having split video_frame into a "left eye" and "right eye"
  optimized_frame = optimize_frame(video_frame, viewer_data);
  decoded_frame = decode_frame(optimized_frame);

  copy_frame_to_texture(decoded_frame, texture);
  viewer_data = get_viewer_data_from_hmd();

  render_frame(decoded_frame, viewer_data);
}</code></pre>

    <!--<p>-->
      <!--First, let’s define “frame time” as the time to complete one iteration of this loop.-->
    <!--</p>-->

    <!--<p>-->
      <!--We profiled our code, and found that:-->
    <!--</p>-->

    <!-- TODO Profile results -->

    <h3>Optimization 1: Async Video Loading</h3>

    <p>
      Loading the video every single frame was taking a long time.
      Our first realization was that the work of loading the video frame is completely independent from the rest of the code!
      So while we’re optimizing, decoding, rendering, we can load more video frames in parallel.
      We created a second thread  to “buffer” the video, loading video frames continuously in the background,
      and putting them onto a queue, where the main thread could take them off.
    </p>

    <p>
      We limited the queue to 10 decoded frames, since decoded frames can be quite large (4096x4096 pixels * 24 bits/pixel for RGB 8-bit is 50.33 MB).
    </p>

    <p>
      <!--This cut down our frame time by XXXX-->
      We also found the video decoding ran much faster than the main loop, so the queue would quickly fill up and stay full.
    </p>

    <p>
      As a secondary optimization, we found that our dequeue function waited for a frame to be available.
      This meant that the main loop couldn’t run faster than video frames were decoded,
      and even if video frames were decoded slightly faster, if the video reader ever hung temporarily, it’d cause a hiccup in the main loop.
      In VR, it’s particularly important to have a fast main loop,
      since that’s where the frame is updated to reflect head-tracking, and high-latency and low framerates on head-tracking cause motion sickness.
      We then changed dequeue to just return <code>NULL</code> immediately if no frame was available,
      and in that case simply skipped updating the frame in the main loop.
      <!--This cut down our frame time by XXX.-->
    </p>

    <h3>Optimization 2: Simplifying the Optimizer</h3>

    <p>
    We implemented view optimization and measured results from that.
    </p>

    <p>
      <b>First Attempt:</b>
      First, we cropped the panoramic video frame that was read to 180&deg; in order to exclude regions that would be too far for the user to turn their head to see.
      Then, taking a yaw and a pitch, we compressed the image.
      To do this, we divided the image up horizontally: left, middle (the inner 20&deg;), and right.
      We scaled down the left and right sides by a factor of 5.
      The middle image was split into top, center and bottom sections.
      The top and bottom sections were similarly scaled down by a factor of 5.
      The middle section was left at full resolution.
    </p>

    <p>
      This way, we had a section in the middle of the image that the user could see as being completely in focus,
      and the rest of the image was blurry, in order to have a smaller size in memory &mdash;
      this optimized image would, in real world circumstances, be sent over a network.
      We measured the time that each of the steps in the view optimization took.
    </p>

    <p>
      <b>Problem:</b>
      On analysis, we saw that the slowest steps, by far, were the resizing steps of the optimizer.
      Each resizing section took over 100 times longer than any other step.
    </p>

    <p>
      <b>Solution:</b>
      Our initial attempt attempted to save space by splitting the image into exclusive regions, and operating on them individually.
      To restore, we would then scale each piece back up and concatenate them, first reassembling the vertical column, then reassembling the horizontal pieces.
      This was far too complicated, and error-prone, resulting in numerous bugs and edge cases.
      In addition, the multiple concatenations each copied every single pixel, meaning many pixels were copied multiple times, which is inefficient
    </p>

    <p>
      We fixed this by using a simpler approach, whereby we simply extract the center square at full resolution,
      and then take the entire image and scale it down.
      Then, to reconstruct it, we re-expand the cropped image to the original size,
      and paint the focused sub-image back in the center.
      While this does create redundant information for the center piece,
      the simpler approach overall reduced optimization time from ~26ms to ~18ms.
    </p>

    <h3>Optimization 3: Pixel Buffer Objects</h3>

    <p>
      We next address the issue of <code>copy_frame_to_texture</code>,
      which copies our decoded frame to the OpenGL texture, which is stored on the GPU.
      At first, we thought the primary issue was being bandwidth bound,
      but we profiled with the Nvidia X Server Info tool, and found that GPU bandwidth wasn’t even near being fully used.
    </p>

    <p>
      We instead found the problem to be waiting. We initially used <code>glTexImage2D</code>,
      which copies the texture to the GPU, every single time we got a new video frame.
      However, it turns out that <code>glTexImage2D</code> is blocking,
      and waits for the GPU to be available, and in particular done using the texture.
      In other words, it wastes a lot of time waiting around.
    <p>

    <p>
      We found a better solution to be using pixel-buffer objects (PBO).
      These allow you to copy your image data into a “pixel buffer”, and then tell the GPU to copy it into the texture, but it runs asynchronously.
      This is similar to asynchronous message passing from class.
      Using pixel-buffer objects reduced the time to copy textures from ~20ms to ~2ms,
      and since we do it once for each eye, it’s about a ~40ms win on total frame time
    <p>

    <h3>Optimization 4: Pipelining Frame Optimization</h3>

    <p>
      The framerate was tied to the amount of time to optimize a frame.
      This was bad, because it resulted in a substantially lower frame rate for the head tracking, which is what makes people sick.
      You move your head, and then see your vision update after 100ms.
      Instead, we decided that even if the video frame takes a while,
      there’s no reason we can’t keep updating the scene with your <code>viewer_data</code>
      (notice <code>viewer_data</code>, containing your head position and orientation,
      is an argument to render_frame--it tells the code where the camera is)
    </p>

    <p>
      We decoupled optimization using a producer-consumer model with a queue.
      The main render thread is now only responsible for rendering the frame.
      Another thread keeps reading and optimizing the video, and it puts each finished frame into a queue.
      The main thread updates its video frame out of the queue if one is available.
      In addition, rendering the scene and decoding the frame are independent parts, so we improve performance by running them in parallel.
      Together, these all make a better user experience.
    </p>

    <p>
      Note that the second thread keeps a copy of viewer data in order to perform the view optimization,
      and the main thread updates it whenever it receives new viewer data. Now, it’s more like:
    </p>

<pre><code>// T1
Queue frameQueue;
Frame frame = frameQueue.dequeue();
ViewerData viewerData;

while (true) {
  if (frameQueue.hasNewFrame())
    frame = frameQueue.dequeue();
  viewerData = get_viewer_data_from_hmd();

  render_frame(optimized_frame, viewer_data);
}

// T2
ViewerData viewerData;
while (videoFrameAvailable()) {
  frame = readFrame();
  frame = deoptimizeFrame(optimizeFrame(frame, viewerData));
  frameQueue.enqueue(frame);
}</code></pre>

    <h3>Optimization 5: Pose Prediction</h3>

    <p>
      Our optimizer works by taking the HMD’s orientation, and then turning it into an OptimizedFrame.
      This frame then has to go through the Optimizer->Renderer queue, and then arrive at the main rendering call.
      But by the time this has happened, about 70ms have passed (this is motion-to-update time),
      and the data the OptimizedFrame was based on is out of date.
    </p>

    <p>
      So, we automatically measure motion-to-update (M2U), and then feed the optimizer orientation data predicted into the future.
      In other words, we view optimize the frame for where your head will be when you see it.
      Prediction is provided by the Oculus SDK, but Oculus clamps predictions to 100ms in the future,
      so we have trouble with spikes, but fortunately we’re under 70ms M2U on average
    </p>

    <h2>Results</h2>

    <p>
      We ran our demo on a Samsung Chronos 7 laptop with a Nvidia GT 630M on Ubuntu 14.10.
      We ran it for 2 minutes while wearing it and looking around.
      It outputs averages of all the statistics we gave hee.
    </p>

    <p>
      We used the Oculus rift to run Conduit and took qualitative measurements, as well as key time metrics.
      We measured motion to update (M2U) latency, which is the time from when you move your head to when you see the updated image appear on the HMD.
    </p>

    <!-- TODO Performance results -->

    <p>
      When viewing the video through the Oculus, we did not notice the blurring that was done outside of the focused region of the frame.
      Our blur factor for the final test was only 3, which wasn’t noticeable on the edges of our vision.
      When we turn quickly, the screen never goes noticeably black on the edges where it’s been cropped.
    </p>

    <p>
      We got a motion-to-update latency of 75ms.
      Also, our optimizations brought the time per frame down from 150ms/frame (6 FPS)  to about 19ms/frame (~50 FPS).
      12ms were spent on display, and 7ms were spent loading the texture.
      Video reading and optimization take almost no time, because we hide latency by pipelining those operations.
    </p>

    <!-- TODO IMPORTANT: What limited speedup? Provide data and measurements. -->
    <!-- This is a good way to get credit even if we didn't accomplish our objective. -->
    <!-- Deeper analysis talks about execution time as distinct components, with proportions of time spent. -->

    <!-- Optimization pipeline is bottleneck -->
    <!-- Latency from blurring in optimization -->

    <p>
      The main bottleneck is the optimization pipeline.
      Blurring and resizing the images is the overwhelming majority of time spent in the view optimizer.
      In order to improve this, we could use the GPU for image resizing to try and make the resize operation faster.
      To improve updating the orientation angle of the user’s head, we also added prediction of the future head position.
      This greatly improved the lag when the user’s head moved quickly, because the optimization pipeline would optimize for the future.
      We didn’t parallelize image resizing because we weren’t able to get OpenCV to run with CUDA support correctly.
    </p>

    <p>
      Latency also arises from texture mapping the frames onto the cylinder using OpenGL. This takes 7ms of the 19ms motion to update latency, and the project could benefit from making it go faster.
    </p>

    <p>
      The display function takes 12ms of the 19ms motion to update latency. OpenGL has to render the cylinder and that takes time. We could perform further optimizations on the display function to improve this time, such as reducing data transfer to the GPU.
    </p>

    <!-- TODO Was your choice of target machine sound? -->
    <p>
    Our choice of target machine was limited, so if we had used a better computer, we could have had faster render times.
    </p>

  </section>
</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    <p class="copyright">
      Conduit maintained by
      <a href="https://github.com/avp">avp</a>
      and
      <a href="https://github.com/grrosegr">grrosegr</a>
    </p>
  </footer>
</div>

</body>
</html>
